{% extends "base.html" %}
{% block content %}
<div class="container" style="padding-top: 20px">
    <h1>Header</h1>
    <hr>

    <div>
        <div class="card">
            <div class="card-header"><h4>Single Responsibility</h4></div>
            <div class="card-body">
                <p>A class should have one and only one reason to change, meaning that a class should have only one job.</p>
                <p>The calculator show single responsibility by the way it separates the actions. In the Calculator class it acts as an interface where the user will input what operation they want to do on some numbers. In the Calculations class it gets the input from the Calculator class. After getting the input the Calculations class will take the number inputs and turn them all into floats. It will then loop through that list of numbers calling the Operations class to do the calculations.</p>
            </div>
        </div>
        <div class="card">
            <div class="card-header"><h4>Open Closed</h4></div>
            <div class="card-body">
                <p>Objects or entities should be open for extension but closed for modification.</p>
                <p>An example of this principle is the Operations class. The operations class can not be modified any further but any python class can call it to preform an operation.</p>
            </div>
        </div>
        <div class="card">
            <div class="card-header"><h4>Liskov Substitution</h4></div>
            <div class="card-body">
                <p>Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.</p>
                <p>An example of this principle is in the Calculations namespace. In the Calculations class it is the parent class for the Addition, Subtraction, and Multiplication classes. The Calculations class is responsible for converting the input tuple to all floats. After converting the tuple on instantiation, The subclass is created which can then refer to the converted tuple. All the subclasses can use and return the same output type.</p>
            </div>
        </div>
        <div class="card">
            <div class="card-header"><h4>Interface Segregation</h4></div>
            <div class="card-body">
                <p>A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.</p>
                <p>For the calculations class it uses this principle by making it calculation type its on object therefore not requiring the other types to unnecessarily have the other types which it won't ever use.</p>

            </div>
        </div>
        <div class="card">
            <div class="card-header"><h4>Dependency Inversion</h4></div>
            <div class="card-body">
                <p>Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.</p>
                <p>The calculation classes show dependency inversion by instead of relying on just performing the operations there it calls another method to perform the actual calculations.</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}